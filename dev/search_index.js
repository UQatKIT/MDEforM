var documenterSearchIndex = {"docs":
[{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation website for \"MDE for Multiscale\"! For detailed theoretical and numerical information on the minimum distance estimation (MDE) method please refer to the accompanying article XXX.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to use the package, clone the GitHub repository to your local machine, navigate through the Terminal to the root directory containing the Project.toml file, start Julia and activate the project in the Terminal via","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia --project=.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then hit ] and instantiate the packages in the project","category":"page"},{"location":"","page":"Home","title":"Home","text":"(MDEforM) pkg> instantiate ","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may now use the package's functionality","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MDEforM","category":"page"},{"location":"","page":"Home","title":"Home","text":"The functions listed under Index are exported by the package and thorough documentation of these functions  can be found in the list of Contents at the bottom of this page.","category":"page"},{"location":"#Toy-Example","page":"Home","title":"Toy Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We want to provide a small example to illustrate the main functionality of the package. We start from the following 2-dimensional fast-slow system of stochastic differential equations (SDE)","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n  dX_ϵ(t) = -α V(X_ϵ(t)) - frac1ϵ pleft( fracX_ϵ(t)ϵ right) dt  + sqrt2 σ dU(t) quad X_ϵ(0) = x_0 \n  dY_ϵ(t) = -fracαϵ V(X_ϵ(t)) - frac1ϵ^2 pleft( Y_ϵ(t) right) dt  + sqrtfrac2 σϵ^2 dU(t) quad Y_ϵ(0) = y_0\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, V is a so-called large-scale potential, p is a 2pi-periodic function, U is a standard Brownian motion, and the parameters alpha sigma epsilon are strictly positive. An examplatory function constellation for V and p is provided by the function NLDO.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is a self-explanatory graphic of V and V + p:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\n\nϵ = 0.1\nV(x) = -x^2 + x^4/12\np(x) = sin(x/ϵ)\nx_range = range(-4,4,2000)\n\n# create and adjust figure components; using CairoMakie.jl here\ndrift_fig = Figure(size=(3840,2160), fontsize = 50)\ndrift_ax = Axis(drift_fig[1, 1],\n  # x-axis\n  xlabel = L\"x\",\n  xticks = LinearTicks(5),\n  # y-axis\n  yticks = LinearTicks(5),\n)\nMakie.xlims!(drift_ax, x_range[1], x_range[end])\ncolsize!(drift_fig.layout, 1, Aspect(1, 1.8))\n  \n\nV_line = lines!(drift_ax, x_range, map(V, x_range), linewidth = 10.0, color = (:darkgrey, 1.0), linestyle = :dash)\nVp_line = lines!(drift_ax, x_range, map(x->V(x)+p(x), x_range), linewidth = 3.0, color = (:black, 1.0))\n\naxislegend(drift_ax,\n[V_line, Vp_line],\n[L\"$x^4/12-x^2$\", L\"$x^4/12 - x^2 + \\sin(x/%$ϵ)$\"],\nlabelsize = 80\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"drift_fig   # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"When epsilon converges to zero, then, by homogenization theory, the process X_epsilon converges weakly in C(0 T R) to the process X solving the SDE","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n  dX(t) = -α K V(X(t)) dt  + sqrt2 σ K dW(t) quad X(0) = X_0\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where K0 is a corrective constant that comes from the cell problem of the homogenization, see also K. The task is to estimate the parameter vartheta = alpha K  through data that comes in form of a long trajectory of the process X_epsilon with \"small\" epsilon  0. We will use the MDE for the estimation. First, we generate synthetic data with the function Langevin. The plot of a trajectory, created with produce_trajectory, looks like the following.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# quadratic potential V with sine oscillation p\nusing MDEforM   # hide\nimport Random   # hide\nRandom.seed!(1111)  # hide\nT = 10\ntrajectory = Langevin(5.0, 10.0, func_config=LDO(), α=2.0, σ=1.0, ϵ=0.1, T=T)\nfig = produce_trajectory(trajectory, T)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We now increase the time horizon T to obtain accurate estimates for vartheta.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MDEforM   # hide\nimport Random   # hide\nRandom.seed!(1111)  # hide\ndata = Langevin(5.0, 10.0, func_config=LDO(), α=2.0, σ=1.0, ϵ=0.1, T=1000)[1]   # only slow process\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Under this configuration the true parameter vartheta is given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MDEforM   # hide\nϑ = 2.0*K(LDO()[3], 1.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can now use the MDE to estimate vartheta. Due to parameter identification issues we must also provide the limit diffusion parameter Sigma = sigma K as input.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MDE_value = MDE(data, \"Langevin\", 1.0*K(LDO()[3], 1.0), 10.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"As we can see the MDE is capable of retrieving the true parameter with multiscale data.","category":"page"},{"location":"#Contents_index","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"multiscale_limit_pairs.md\", \"invariant_densities.md\", \"MDE_functionals.md\", \"MDE_optimizers.md\", \"MDE_asymptotic_variances.md\"]\nDepth = 1","category":"page"},{"location":"#Index_index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"invariant_densities/#Invariant-Densities","page":"Invariant Densities","title":"Invariant Densities","text":"","category":"section"},{"location":"invariant_densities/#Functions","page":"Invariant Densities","title":"Functions","text":"","category":"section"},{"location":"invariant_densities/","page":"Invariant Densities","title":"Invariant Densities","text":"μ\n∂ϑ_μ\n∂Σ_μ","category":"page"},{"location":"invariant_densities/#MDEforM.μ","page":"Invariant Densities","title":"MDEforM.μ","text":"μ(x::Real, ϑ::Real, Σ::Real, V::Function)\n\nReturn function value of invariant density at x defined through a potential V and given parameter values ϑ and Σ.\n\nThe invariant density is given by the formula\n\nbeginaligned\n    mu(x vartheta Sigma V) = frac1Z(ϑ Σ) expleft( -fracvarthetaSigma V(x) right) quad x in R\nendaligned\n\nwhere V is potential on R, e.g. V(x) = x^44 - x^22, and Z(ϑ Σ)0 is a normalization constant.\n\n\n\nArguments\n\nx::Real:            argument x at which to evaluate the function.\nϑ::Real:            positive drift coefficient vartheta.\nΣ::Real:            positive diffusion coefficient Sigma.\nV::Function:        defining potential function V.\n\n\n\nExamples\n\njulia> lines(range(-5, 5, 1000), map(y -> μ(y, 1, 1, x -> x^2/2), range(-5, 5, 1000)))\n\n\n\n\n\n","category":"function"},{"location":"invariant_densities/#MDEforM.∂ϑ_μ","page":"Invariant Densities","title":"MDEforM.∂ϑ_μ","text":"∂ϑ_μ(x::Real, ϑ::Real, Σ::Real, V::Function)\n\nReturn function value of derivative of invariant density with respect to drift parameter ϑ at x for given parameter values ϑ and Σ and potential V.\n\nThe derivative of the invariant density with respect to the drift parameter is given by the formula\n\nbeginaligned\n    partial_ϑ   mu(x vartheta Sigma V) = -mu(x vartheta Sigma V) left( fracV(x)Sigma + fracpartial_vartheta Z(ϑ Σ)Z(ϑ Σ) right) quad x in R 05cm\n    partial_vartheta Z(ϑ Σ) = -frac1Sigma int_R V(y) expleft(-fracvarthetaSigma V(y)right)  dy\nendaligned\n\nwhere V is a potential on R, e.g. V(x) = x^22 - x^44, and Z(ϑ Σ)0 is a normalization constant.\n\n\n\nArguments\n\nx::Real:            argument x at which to evaluate the function.\nϑ::Real:            positive drift coefficient vartheta.\nΣ::Real:            positive diffusion coefficient Sigma.\nV::Function:        defining potential function V.\n\n\n\nExamples\n\njulia> lines(range(-5, 5, 1000), map(x -> ∂ϑ_μ(x, 1, 1, x -> x^2/2), range(-5, 5, 1000)))\n\n\n\n\n\n","category":"function"},{"location":"invariant_densities/#MDEforM.∂Σ_μ","page":"Invariant Densities","title":"MDEforM.∂Σ_μ","text":"∂Σ_μ(x::Real, ϑ::Real, Σ::Real, V::Function)\n\nReturn function value of derivative of invariant density with respect to diffusion parameter Σ at x for given parameter values ϑ and Σ and potential V.\n\nThe derivative of the invariant density with respect to the diffusion parameter is given by the formula\n\nbeginaligned\n    partial_Sigma   mu(x vartheta Sigma V) = mu(x vartheta Sigma V) left( fracvartheta V(x)Sigma^2 - fracpartial_Sigma Z(ϑ Σ)Z(ϑ Σ) right) quad x in R 05cm\n    partial_Sigma Z(vartheta Sigma) = fracvarthetaSigma^2 int_R V(y) expleft(-fracvarthetaSigma V(y)right)  dy\nendaligned\n\nwhere V is a potential on R, e.g. V(x) = x^22 - x^44, and Z(ϑ Σ)0 is a normalization constant.\n\n\n\nArguments\n\nx::Real:            argument x at which to evaluate the function.\nϑ::Real:            positive drift coefficient vartheta.\nΣ::Real:            positive diffusion coefficient Sigma.\nV::Function:        defining potential function V.\n\n\n\nExamples\n\njulia> lines(range(-5, 5, 1000), map(x -> ∂Σ_μ(x, 1, 1, x -> x^2/2), range(-5, 5, 1000)))\n\n\n\n\n\n","category":"function"},{"location":"invariant_densities/#Index","page":"Invariant Densities","title":"Index","text":"","category":"section"},{"location":"invariant_densities/","page":"Invariant Densities","title":"Invariant Densities","text":"Pages = [\"invariant_densities.md\"]","category":"page"},{"location":"multiscale_limit_pairs/#Multiscale-System-and-Homogenized-Limit-Pairs","page":"Multiscale System and Homogenized Limit Pairs","title":"Multiscale System and Homogenized Limit Pairs","text":"","category":"section"},{"location":"multiscale_limit_pairs/","page":"Multiscale System and Homogenized Limit Pairs","title":"Multiscale System and Homogenized Limit Pairs","text":"The considered multiscale examples fit into the setting of homogenization for SDEs where there is a system of SDEs","category":"page"},{"location":"multiscale_limit_pairs/","page":"Multiscale System and Homogenized Limit Pairs","title":"Multiscale System and Homogenized Limit Pairs","text":"beginaligned\n    d X_epsilon = left frac1epsilon a_0(X_epsilon Y_epsilon) + a_1(X_epsilon Y_epsilon) right dt + alpha_0(X_epsilon Y_epsilon) dU_t + alpha_1(X_epsilon Y_epsilon) dV_t qquad textitfootnotesize slow dynamics 025cm\n    d Y_epsilon = left frac1epsilon^2 b_0(X_epsilon Y_epsilon) + frac1epsilon b_1(X_epsilon Y_epsilon) + b_2(X_epsilon Y_epsilon) right dt + frac1epsilon beta(X_epsilon Y_epsilon) dV_t qquad textitfootnotesize fast dynamics\nendaligned","category":"page"},{"location":"multiscale_limit_pairs/","page":"Multiscale System and Homogenized Limit Pairs","title":"Multiscale System and Homogenized Limit Pairs","text":"depending on a small scale parameter epsilon  0 and the slow process X_epsilon converges weakly, in the sense of the induced probability measures, to the solution X of the homogenized limit SDE","category":"page"},{"location":"multiscale_limit_pairs/","page":"Multiscale System and Homogenized Limit Pairs","title":"Multiscale System and Homogenized Limit Pairs","text":"beginaligned\n    dX = f(X)dt + g(X)dW_t\nendaligned","category":"page"},{"location":"multiscale_limit_pairs/","page":"Multiscale System and Homogenized Limit Pairs","title":"Multiscale System and Homogenized Limit Pairs","text":"The majority of the following functions give realizations of the multiscale processes and their respective homogenized limit in form of a time series.","category":"page"},{"location":"multiscale_limit_pairs/#Functions","page":"Multiscale System and Homogenized Limit Pairs","title":"Functions","text":"","category":"section"},{"location":"multiscale_limit_pairs/","page":"Multiscale System and Homogenized Limit Pairs","title":"Multiscale System and Homogenized Limit Pairs","text":"Fast_OU\nLDA\nNLDAM\nNSDP\nLangevin\nK\nLDO\nNLDO\nBurger\nFast_chaotic\nproduce_trajectory","category":"page"},{"location":"multiscale_limit_pairs/#MDEforM.Fast_OU","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.Fast_OU","text":"Fast_OU(x0::Real, y0::Real; <keyword arguments>)\n\nReturn a 2-dimensional fast-slow Ornstein-Uhlenbeck process starting at (x0, y0) as a discretized time series.\n\nThe corresponding stochastic differential equation is defined for t in 0T as\n\nbeginaligned\n  dX_ϵ(t) = left( frac1ϵ σ(X_ϵ(t)) Y_ϵ(t) + h(X_ϵ(t) Y_ϵ(t)) - σ(X_ϵ(t))σ(X_ϵ(t)) right) dt quad X_ϵ(0) = x_0 \n  dY_ϵ(t) = -frac1ϵ^2 Y_ϵ(t) + fracsqrt2ϵ dV(t) quad Y_ϵ(0) = y_0\nendaligned\n\nHere, σ is the first derivative of σ. A simple Euler-Maruyama discretization is implemented for the generation of the time series.\n\n\n\nArguments\n\nx0::Real:                             initial point x_0 of slow process X_ϵ.\ny0::Real:                             initial point y_0 of fast process Y_ϵ.\nfunc_config::NTuple{3, Function}:     collection of the functions h σ and σ.\nϵ::Real=0.1:                          positive small scale parameter ϵ.\nT::Real=100:                          time horizon of time series.\ndt::Real=1e-3:                        time discretization step used in the Euler-Maruyama scheme.\n\n\n\nExamples\n\n# linear drift with additive noise\nT = 10.0\ntrajectory = Fast_OU(1.0, 1.0, func_config=LDA(), ϵ=0.1, T=T)\nfig = produce_trajectory(trajectory, T)\n#save(\"trajectory_fast_OU_process.pdf\", fig)\n\n# nonlinear drift with additive and multiplicative noise\nT = 10.0\ntrajectory = Fast_OU(1.0, 1.0, func_config=NLDAM(), ϵ=0.1, T=T)\nfig = produce_trajectory(trajectory, T)\n\n# nonlinear drift with additive and multiplicative noise, non-symmetric double-well potential\nT = 10.0\ntrajectory = Fast_OU(1.0, 1.0, func_config=NSDP(), ϵ=0.1, T=T)\nfig = produce_trajectory(trajectory, T)\n\n\n\nSee also LDA, NLDAM, NSDP.\n\n\n\n\n\nFast_OU(X0::Real; <keyword arguments>)\n\nReturn a one-dimensional limit process, homogenized from the fast-slow Ornstein-Uhlenbeck process, starting at X0 as a discretized time series.\n\nThe corresponding stochastic differential equation is defined for t in 0T as\n\nbeginaligned\n  dX(t) = barh(X(t)) dt - sqrt2 σ(X(t))^2 dW(t) quad X(0) = X_0\nendaligned\n\nHere, barh is the average of h with respect to the invariant measure of the fast process Y_ϵ of the fast-slow Ornstein-Uhlenbeck process.  A simple Euler-Maruyama discretization is implemented for the generation of the time series.\n\n\n\nArguments\n\nX0::Real:                               initial point X_0 of limit process X.\nfunc_config::NTuple{3, Function}:       collection of the functions barh and σ.\nT::Real=100:                            time horizon of time series.\ndt::Real=1e-3:                          time discretization step used in the Euler-Maruyama scheme.\n\n\n\nExamples\n\njulia> h_aver = x -> -x   # corresponds to an ordinary Ornstein-Uhlenbeck process\njulia> σ = x -> sqrt(2)\njulia> Fast_OU(1.0, func_config=(h_aver, σ))\n\n\n\nSee also LDA, NLDAM, NSDP.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.LDA","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.LDA","text":"LDA(A::Real=1, σ::Real=1)\n\nReturn a tuple of functions used for the definition of Fast_OU.\n\nThe returned functions are\n\nbeginaligned\n  h(x) = -Ax quad A  0 \n  σ(x) = sqrtσquad\n  σ(x) = 0  quad σ0\nendaligned\n\nThey yield a linear drift with additive noise.\n\n\n\nArguments\n\nA::Real=1:        non-negative real number.\nσ::Real=1:        positive real number.\n\n\n\nSee also Fast_OU.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.NLDAM","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.NLDAM","text":"NLDAM(A::Real=2, B::Real=10, σ_a::Real=1, σ_b::Real=1)\n\nReturn a tuple of functions used for the definition of Fast_OU.\n\nThe returned functions are\n\nbeginaligned\n  h(x) = Ax - Bx^3 quad A B  0 \n  σ(x) = sqrtσ_a + σ_b x^2 quad\n  σ(x) = fracσ_b xsqrtσ_a + σ_b x^2 quad σ_a σ_b  0\nendaligned\n\nThey yield a nonlinear drift with additive and multiplicative noise.\n\n\n\nArguments\n\nA::Real=2:          non-negative real number.\nB::Real=10:         non-negative real number.\nσ_a::Real=1:        positive real number.\nσ_b::Real=1:        positive real number.\n\n\n\nSee also Fast_OU.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.NSDP","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.NSDP","text":"NSDP(A::Real=1, B::Real=2, C::Real=5, σ_a::Real=1, σ_b::Real=1)\n\nReturn a tuple of functions used for the definition of Fast_OU.\n\nThe returned functions are\n\nbeginaligned\n  h(x) = Ax + Bx^2 - Cx^3 quad A B C  0 \n  σ(x) = sqrtσ_a + σ_b x^2 quad\n  σ(x) = fracσ_b xsqrtσ_a + σ_b x^2 quad σ_a σ_b  0\nendaligned\n\nThey yield a nonlinear, non-symmetric double-well potential drift with additive and multiplicative noise.\n\n\n\nArguments\n\nA::Real=1:          non-negative real number.\nB::Real=2:          non-negative real number.\nC::Real=5:          non-negative real number.\nσ_a::Real=1:        positive real number.\nσ_b::Real=1:        positive real number.\n\n\n\nSee also Fast_OU.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.Langevin","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.Langevin","text":"Langevin(x0::Real, y0::Real; <keyword arguments>)\n\nReturn a 2-dimensional overdamped Langevin process with a large-scale potential and a fast oscillating part starting at (x0, y0) as a discretized time series.\n\nThe corresponding stochastic differential equation is defined for t in 0T as\n\nbeginaligned\n  dX_ϵ(t) = -α V(X_ϵ(t)) - frac1ϵ pleft( fracX_ϵ(t)ϵ right) dt  + sqrt2 σ dU(t) quad X_ϵ(0) = x_0 \n  dY_ϵ(t) = -fracαϵ V(X_ϵ(t)) - frac1ϵ^2 pleft( Y_ϵ(t) right) dt  + sqrtfrac2 σϵ^2 dU(t) quad Y_ϵ(0) = y_0\nendaligned\n\nHere, V is a large-scale potential and p a 2π-periodic function, see LDO or NLDO. Note that Y_ϵ = X_ϵϵ.  A simple Euler-Maruyama discretization is implemented for the generation of the time series.\n\n\n\nArguments\n\nx0::Real:                               initial point x_0 of slow process X_ϵ.\ny0::Real:                               initial point y_0 of fast process Y_ϵ.\nfunc_config::NTuple{4, Function}:       collection of the functions V V p and p.\nα::Real:                                non-negative drift parameter α.\nσ::Real:                                positive diffusion parameter σ.\nϵ::Real=0.1:                            positive small scale parameter ϵ.\nT::Real=100:                            time horizon of time series.\ndt::Real=1e-3:                          time discretization step used in the Euler-Maruyama scheme.\n\n\n\nExamples\n\n# quadratic potential V with sine oscillation p\nT = 10.0\ntrajectory = Langevin(1.0, 3.0, func_config=LDO(), α=2.0, σ=1.0, ϵ=0.1, T=T)\nfig = produce_trajectory(trajectory, T)\n#save(\"trajectory_Langevin_process.pdf\", fig)\n\n\n\nSee also LDO, NLDO.\n\n\n\n\n\nLangevin(X0::Real; <keyword arguments>)\n\nReturn a one-dimensional overdamped limit Langevin process, homogenized from the multiscale overdamped Langevin process, starting at X0 as a discretized time series.\n\nThe corresponding stochastic differential equation is defined for t in 0T as\n\nbeginaligned\n  dX(t) = -α K V(X(t)) dt  + sqrt2 σ K dW(t) quad X(0) = X_0\nendaligned\n\nHere, K is a corrective constant that comes from the cell problem of the homogenization, see also K, and is computed inside the function. A simple Euler-Maruyama discretization is implemented for the generation of the time series.\n\n\n\nArguments\n\nX0::Real:                               initial point X_0 of limit process X.\nfunc_config::NTuple{4, Function}:       collection of the functions V V p and p.\nα::Real:                                non-negative drift parameter α.\nσ::Real:                                positive diffusion parameter σ.\nT::Real=100:                            time horizon of time series.\ndt::Real=1e-3:                          time discretization step used in the Euler-Maruyama scheme.\n\n\n\nSee also LDO, NLDO.\n\n\n\n\n\nLangevin(x0::Vector{<:Real}, y0::Vector{<:Real}; <keyword arguments>)\n\nReturn a 4-dimensional overdamped Langevin process with a quadratic potential and a fast separable oscillating part starting at (x0, y0) as a discretized time series.\n\nThe corresponding stochastic differential equation is defined for t in 0T as\n\nbeginaligned\n  dX_ϵ(t) \n  = beginpmatrix\n      dX^(1)_ϵ(t) 01cm\n      dX^(2)_ϵ(t)\n    endpmatrix\n  = - M X_ϵ(t) - frac1ϵ \n    beginpmatrix\n      p_1left(X^(1)_ϵ(t)ϵright) 01cm\n      p_2left(X^(2)_ϵ(t)ϵright)\n    endpmatrix dt  + sqrt2 σ dU(t) quad X_ϵ(0) = x_0 \n  dY_ϵ(t) = fracX_ϵϵ\nendaligned\n\nA simple Euler-Maruyama discretization is implemented for the generation of the time series.\n\n\n\nArguments\n\nx0::Vector{<:Real}:                     initial point x_0 in mathbbR^2 of slow process X_ϵ.\ny0::Vector{<:Real}:                     initial point y_0 in mathbbR^2 of slow process Y_ϵ.\nfunc_config::NTuple{2, Function}:       collection of the 2pi-periodic functions p_1 and p_2.\nM::Array{<:Real, 2}:                    positive definite drift matrix M in R^2 times 2.\nσ::Real:                                positive diffusion parameter σ.\nϵ::Real=0.1:                            positive small scale parameter ϵ.\nT::Real=100:                            time horizon of time series.\ndt::Real=1e-3:                           time discretization step used in the Euler-Maruyama scheme.\n\n\n\nExamples\n\n# quadratic potential V and fast separable oscillating part in 2D\ntrajectory = Langevin([-5.0, -5.0], [0.0, 0.0], func_config=(x-> cos(x), x -> 1/2*cos(x)), M=[4 2;2 3], σ=5.0, ϵ=0.05, T=10.0)\nfig = produce_trajectory(trajectory)\n#save(\"trajectory_Langevin_process_2D.pdf\", fig)\n\n\n\n\n\nLangevin(X0::Vector{<:Real}; <keyword arguments>)\n\nReturn a 2-dimensional overdamped limit Langevin process, homogenized from the multiscale overdamped Langevin process,  starting at X0 as a discretized time series.\n\nThe corresponding stochastic differential equation is defined for t in 0T as\n\nbeginaligned\n  dX(t) = - K M X(t) dt  + sqrt2 σ K dW(t) quad X(0) = X_0\nendaligned\n\nHere, K in mathbbR^2 times 2 is a corrective constant that comes from the cell problem of the homogenization and is computed inside the function.  A simple Euler-Maruyama discretization is implemented for the generation of the time series.\n\n\n\nArguments\n\nX0::Vector{<:Real}:                     initial point X_0 in mathbbR^2 of limit process X.\nfunc_config::NTuple{2, Function}:       collection of the 2pi-periodic functions p_1 and p_2.\nM::Array{<:Real, 2}:                    positive definite drift matrix M in mathbbR^2 times 2.\nσ::Real:                                positive diffusion parameter σ.\nT::Real=100:                            time horizon of time series.\ndt::Real=1e-3:                           time discretization step used in the Euler-Maruyama scheme.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.K","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.K","text":"K(p::Function, σ::Real)\n\nReturn corrective constant of the cell problem of the homogenization in the overdamped Langevin case.\n\n\n\nArguments\n\np:                2π-periodic function.\nσ:                positive diffusion parameter of slow process X_ϵ.\n\n\n\nSee also Langevin.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.LDO","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.LDO","text":"LDO()\n\nReturn a tuple of functions used for the definition of Langevin.\n\nThe returned functions are\n\nbeginaligned\n  V(x) = frac12 x^2 quad\n  V(x) = x \n  p(x) = sin(x) quad\n  p(x) = cos(x)\nendaligned\n\nThey yield a quadratic potential drift with a sine oscillation.\n\n\n\nSee also Langevin.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.NLDO","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.NLDO","text":"NLDO()\n\nReturn a tuple of functions used for the definition of Langevin.\n\nThe returned functions are\n\nbeginaligned\n  V(x) = frac14 x^4 - frac12 x^2 quad\n  V(x) = x^3 - x \n  p(x) = sin(x) quad\n  p(x) = cos(x)\nendaligned\n\nThis yields a bistable potential drift with a sine oscillation.\n\n\n\nExamples\n\n# a slightly different potential (for illustrative reasons)\nϵ = 0.1\nV(x) = -x^2 + x^4/12\np(x) = sin(x/ϵ)\nx_range = range(-4,4,2000)\n\n# create and adjust figure components; using CairoMakie.jl here\ndrift_fig = Figure(size=(3840,2160), fontsize = 50)\ndrift_ax = Axis(drift_fig[1, 1],\n  # x-axis\n  xlabel = L\"x\",\n  xticks = LinearTicks(5),\n  # y-axis\n  yticks = LinearTicks(5),\n)\nMakie.xlims!(drift_ax, x_range[1], x_range[end])\ncolsize!(drift_fig.layout, 1, Aspect(1, 1.8))\n  \n\nV_line = lines!(drift_ax, x_range, map(V, x_range), linewidth = 10.0, color = (:darkgrey, 1.0), linestyle = :dash)\nVp_line = lines!(drift_ax, x_range, map(x->V(x)+p(x), x_range), linewidth = 3.0, color = (:black, 1.0))\n\naxislegend(drift_ax,\n[V_line, Vp_line],\n[L\"$x^4/12-x^2$\", L\"$x^4/12 - x^2 + \\sin(x/%$ϵ)$\"],\nlabelsize = 80\n)\n\ndrift_fig\n\n\n\nSee also Langevin.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.Burger","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.Burger","text":"Burger(x0::Real, y0::Real, z0::Real; <keyword arguments>)\n\nReturn a three-dimensional process described through a truncated Burger's equation starting at (x0, y0, z0) as a discretized time series.\n\nThe corresponding stochastic differential equation is defined for t in 0T as\n\nbeginaligned\n  dX_ϵ(t) = left( ν X_ϵ(t) - frac12ϵ (X_ϵ(t)Y_ϵ(t) + Y_ϵ(t)Z_ϵ(t)) right) dt                                                 quad X_ϵ(0) = x_0  \n  dY_ϵ(t) = left( ν Y_ϵ(t) - frac3ϵ^2 Y_ϵ(t) - frac12ϵ (2 X_ϵ(t)Z_ϵ(t) - X_ϵ(t)^2) right) dt + fracq_1ϵ dV_1(t)    quad Y_ϵ(0) = y_0  \n  dZ_ϵ(t) = left( ν Z_ϵ(t) - frac8ϵ^2 Y_ϵ(t) - frac32ϵ X_ϵ(t)Y_ϵ(t) right) dt + fracq_2ϵ dV_2(t)                   quad Z_ϵ(0) = z_0\nendaligned\n\nA simple Euler-Maruyama discretization is implemented for the generation of the time series.\n\n\n\nArguments\n\nx0::Real:         initial point x_0 of slow process X_ϵ.\ny0::Real:         initial point y_0 of fast process Y_ϵ.\nz0::Real:         initial point z_0 of fast process Z_ϵ.\nν::Real:          positive parameter ν.\nq1::Real:         positive parameter q_1.\nq2::Real:         positive parameter q_2.\nϵ::Real=0.1:      positive small scale parameter ϵ.\nT::Real=100:      time horizon of time series.\ndt::Real=1e-3:    time discretization step used in the Euler-Maruyama scheme.\n\n\n\n\n\nBurger(X0::Real; <keyword arguments>)\n\nReturn a one-dimensional process described through a limit truncated Burger's equation, homogenized from the multiscale truncated Burger's equation, starting at X0 as a discretized time series.\n\nThe corresponding stochastic differential equation is defined for t in 0T as\n\nbeginaligned\n  dX(t) = left(AX(t) - BX(t)^3right) dt  + sqrtσ_a + σ_bX(t)^2 dW(t) quad X(0) = X_0\nendaligned\n\nwith the paraters\n\nbeginaligned\n  A = ν + fracq_1^2396 + fracq_2^2352 quad B = frac112 quad σ_a = fracq_1^2 q_2^22112 quad σ_b = fracq_1^236\nendaligned\n\nA simple Euler-Maruyama discretization is implemented for the generation of the time series.\n\n\n\nArguments\n\nX0::Real:         initial point X_0 of limit process X.\nν::Real:          positive parameter ν.\nq1::Real:         positive parameter q_1.\nq2::Real:         positive parameter q_2.\nT::Real=100:      time horizon of time series.\ndt::Real=1e-3:     time discretization step used in the Euler-Maruyama scheme.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.Fast_chaotic","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.Fast_chaotic","text":"Fast_chaotic(xy0; <keyword arguments>)\n\nReturn the 4-dimensional solution path of a fast chaotic noise system starting at xy0 as a discretized time series.\n\nThe corresponding ordinary differential equation is defined for t in 0T as\n\nbeginaligned\n  fracdX_epsilondt = AX - BX^3 + fraclambdaepsilon Y_epsilon^(2) quad X_ϵ(0) = x_0 \n  fracdY_epsilon^(1)dt = frac10epsilon^2 left( Y_epsilon^(2) - Y_epsilon^(1) right) quad Y_epsilon^(1)(0) = y_0^(1) \n  fracdY_epsilon^(2)dt = frac1epsilon^2 left( 28 Y_epsilon^(1) - Y_epsilon^(2) - Y_epsilon^(1)Y_epsilon^(3) right) quad Y_epsilon^(2)(0) = y_0^(2) \n  fracdY_epsilon^(3)dt = frac1epsilon^2 left( Y_epsilon^(1)Y_epsilon^(2) - frac83 Y_epsilon^(3) right) quad Y_epsilon^(3)(0) = y_0^(3)\nendaligned\n\nThe ODE is solved with a fourth order Runge-Kutta scheme of the DifferentialEquations.jl  package.\n\n\n\nArguments\n\nxy0::Vector{<:Real}:  initial point (x_0 y_0^(1) y_0^(2) y_0^(3)) in mathbbR^4.\nA::Real:              positive parameter A.\nB::Real:              positive parameter B.\nλ::Real:              positive parameter λ.\nT::Real=100:          time horizon of time series.\ndt::Real=1e-3:        time discretization step used in the ODE solver.\n\n\n\n\n\nFast_chaotic(X0::Real; <keyword arguments>)\n\nReturn a one-dimensional process described through a limit fast chaotic noise, homogenized from the multiscale fast chaotic noise system, starting at X0 as a discretized time series.\n\nThe corresponding stochastic differential equation is defined for t in 0T as\n\nbeginaligned\n  dX(t) = left(AX(t) - BX(t)^3right) dt  + sqrtσ dW(t) quad X(0) = X_0\nendaligned\n\nThe diffusion parameter σ is given by the Green-Kubo formula \n\nbeginaligned\n  sigma = fraclambda^22 int_0^infty lim_T rightarrow infty frac1T int_0^T Y_ϵ=1^(2)(s) Y_ϵ=1^(2)(s+t)  ds  dt\nendaligned\n\nwhich requires to be numerically computed or estimated through data. A simple Euler-Maruyama discretization is implemented for the generation of the time series.\n\n\n\nArguments\n\nX0::Real:         initial point X_0 of limit process X.\nA::Real:          positive drift parameter A.\nB::Real:          positive drift parameter B.\nσ::Real:          positive diffusion parameter σ.\nT::Real=100:      time horizon of time series.\ndt::Real=1e-3:    time discretization step used in the Euler-Maruyama scheme.\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#MDEforM.produce_trajectory","page":"Multiscale System and Homogenized Limit Pairs","title":"MDEforM.produce_trajectory","text":"produce_trajectory(trajectory, T)\n\nGenerate a plot of a 2-dimensional (slow + fast scale process) multiscale time series of length T using the CairoMakie.jl package.\n\n\n\nArguments\n\ntrajectory::NTuple{2, Vector{<:Real}}:   2-dimensional time series of length T\nT::Real:                                 time horizon of time series.\n\n\n\nExamples\n\n# quadratic potential V with sine oscillation p\nT = 10.0\ntrajectory = Langevin(1.0, -4.0, func_config=LDO(), α=2.0, σ=1.0, ϵ=0.1, T=T)\nfig = produce_trajectory(trajectory, T)\n\n\n\n\n\nproduce_trajectory(trajectory)\n\nGenerate a plot of a 4-dimensional (slow + fast scale process) multiscale time series using the CairoMakie.jl package.\n\n\n\nArguments\n\ntrajectory::NTuple{2, Array{<:Real, 2}}:   4-dimensional time series\n\n\n\nExamples\n\n# quadratic potential V and fast separable oscillating part in 2D\ntrajectory = Langevin([-5.0, -5.0], [10.0, 10.0], func_config=(x-> cos(x), x -> 1/2*cos(x)), M=[4 2;2 3], σ=5.0, ϵ=0.05, T=10.0)\nfig = produce_trajectory(trajectory)\n\n\n\n\n\n","category":"function"},{"location":"multiscale_limit_pairs/#Index","page":"Multiscale System and Homogenized Limit Pairs","title":"Index","text":"","category":"section"},{"location":"multiscale_limit_pairs/","page":"Multiscale System and Homogenized Limit Pairs","title":"Multiscale System and Homogenized Limit Pairs","text":"Pages = [\"multiscale_limit_pairs.md\"]","category":"page"},{"location":"MDE_asymptotic_variances/#Asymptotic-Variances-of-the-MDE","page":"Asymptotic Variances of the MDE","title":"Asymptotic Variances of the MDE","text":"","category":"section"},{"location":"MDE_asymptotic_variances/#Introduction","page":"Asymptotic Variances of the MDE","title":"Introduction","text":"","category":"section"},{"location":"MDE_asymptotic_variances/","page":"Asymptotic Variances of the MDE","title":"Asymptotic Variances of the MDE","text":"In the multiscale overdamped Langevin drift parameter estimation problem, cf. section 4 of the article XXX, the MDE is asymptotically normal under the true parameter  vartheta_0 in Theta_0 as epsilon rightarrow 0 with ","category":"page"},{"location":"MDE_asymptotic_variances/","page":"Asymptotic Variances of the MDE","title":"Asymptotic Variances of the MDE","text":"beginaligned\n    sqrtT_epsilon left(hatvartheta_T_epsilon(X_epsilon) - vartheta_0 right) oversetmathcalD_psi(vartheta_0)longrightarrow J(vartheta_0)^-1 mathcalN_1(0 tau^2(vartheta_0)) quad textas  epsilon rightarrow 0\nendaligned","category":"page"},{"location":"MDE_asymptotic_variances/","page":"Asymptotic Variances of the MDE","title":"Asymptotic Variances of the MDE","text":"The following functions calculate the asymptotic variance figuring above.","category":"page"},{"location":"MDE_asymptotic_variances/#Functions","page":"Asymptotic Variances of the MDE","title":"Functions","text":"","category":"section"},{"location":"MDE_asymptotic_variances/","page":"Asymptotic Variances of the MDE","title":"Asymptotic Variances of the MDE","text":"Σ_∞_QdP\nΣ_∞_QrP","category":"page"},{"location":"MDE_asymptotic_variances/#MDEforM.Σ_∞_QdP","page":"Asymptotic Variances of the MDE","title":"MDEforM.Σ_∞_QdP","text":"Σ_∞_QdP(ϑ, Σ)\n\nReturn the asymptotic variance of the MDE in the multiscale overdamped Langevin drift parameter estimation problem with a quadratic potential, drift parameter ϑ, and diffusion parameter Σ.\n\nThe asymptotic variance is given by\n\nbeginaligned\n  fractau^2(vartheta Sigma)J(vartheta Sigma)^2 = frac2SigmaJ(vartheta Sigma)^2 int_R Phi(x)^2 mu(x vartheta Sigma V)  dx\nendaligned\n\nwhere\n\nbeginaligned\n  J(vartheta Sigma) =  partial_vartheta mathscrC_vartheta _L^2(varphi) quad Phi(x) = frac1Sigma mu(x vartheta Sigma V) int_-infty^x h(z) mu(x vartheta Sigma V)  dz quad x in R\nendaligned\n\nHere mu(x vartheta Sigma V) corresponds to μ with V(x) = x^22. In the case of such a quadratic potential V it holds\n\nbeginaligned\n  J(vartheta Sigma) = frac34 beta left( fracSigmavartheta^2 right)^2 sigma_2^5 quad h(z) = fracSigma2 vartheta^2 beta left sigma_1^3 (1 - sigma_1^2 z^2) exp left( -fracsigma_1^2 z^22 right) - sigma_2^3 right quad z in R\nendaligned\n\nwith\n\nbeginaligned\n      sigma_1^2 = fracbeta^2 varthetavartheta + Sigmabeta^2  quad sigma_2^2 = fracbeta^2 varthetavartheta + 2 Sigmabeta^2 \nendaligned\n\nwarning: Warning\nThe running times for a single evaluation can take some time due to the involved integrations, but it usually needs to be computed only once.\n\n\n\nArguments\n\nϑ::Real:                    positive drift coefficient vartheta.\nΣ::Real:                    positive diffusion coefficient Sigma.\n\n\n\nExamples\n\njulia> Σ_∞_QdP(1.2, 0.6)\n\n\n\nSee also μ, Σ_∞_QrP.\n\n\n\n\n\n","category":"function"},{"location":"MDE_asymptotic_variances/#MDEforM.Σ_∞_QrP","page":"Asymptotic Variances of the MDE","title":"MDEforM.Σ_∞_QrP","text":"Σ_∞_QrP(ϑ, Σ)\n\nReturn the asymptotic variance of the MDE in the multiscale overdamped Langevin drift parameter estimation problem with a quartic potential, drift parameter ϑ, and diffusion parameter Σ.\n\nThe asymptotic variance is given by\n\nbeginaligned\n  fractau^2(vartheta Sigma)J(vartheta Sigma)^2 = frac2SigmaJ(vartheta Sigma)^2 int_R Phi(x)^2 mu(x vartheta Sigma V)  dx\nendaligned\n\nwhere\n\nbeginaligned\n  J(vartheta Sigma) =  partial_vartheta mathscrC_vartheta _L^2(varphi) quad Phi(x) = frac1Sigma mu(x vartheta Sigma V) int_-infty^x h(z) mu(x vartheta Sigma V)  dz quad x in R\nendaligned\n\nHere mu(x vartheta Sigma V) corresponds to μ with V(x) = x^44-x^22. In this case it holds\n\nbeginaligned\n  J(vartheta Sigma) = int_R (partial_vartheta mu(vartheta Sigma V) ast k_beta)(x)  partial_vartheta mu(x vartheta Sigma V)  dx 05cm\n  h(z) = (partial_vartheta mu(vartheta Sigma V) ast k_beta)(z) - int_R (partial_vartheta mu(vartheta Sigma V) ast k_beta)(x)  mu(x vartheta Sigma V)  dx\nendaligned\n\nwarning: Warning\nThe running times for a single evaluation can take some time due to the involved integrations, but it usually needs to be computed only once.\n\n\n\nArguments\n\nϑ::Real:                    positive drift coefficient vartheta.\nΣ::Real:                    positive diffusion coefficient Sigma.\n\n\n\nExamples\n\njulia> Σ_∞_QrP(1.2, 0.6)\n\n\n\nSee also μ, k, Σ_∞_QdP.\n\n\n\n\n\n","category":"function"},{"location":"MDE_asymptotic_variances/#Index","page":"Asymptotic Variances of the MDE","title":"Index","text":"","category":"section"},{"location":"MDE_asymptotic_variances/","page":"Asymptotic Variances of the MDE","title":"Asymptotic Variances of the MDE","text":"Pages = [\"MDE_asymptotic_variances.md\"]","category":"page"},{"location":"MDE_optimizers/#Optimization-Task-of-the-MDE","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"","category":"section"},{"location":"MDE_optimizers/#Introduction","page":"Optimization Task of the MDE","title":"Introduction","text":"","category":"section"},{"location":"MDE_optimizers/","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"The MDE is based on the following minimization task","category":"page"},{"location":"MDE_optimizers/","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"beginaligned\n  hatvartheta_T(X_epsilon) = argmin_vartheta in Theta Delta_T(vartheta X_epsilon)\nendaligned","category":"page"},{"location":"MDE_optimizers/","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"where","category":"page"},{"location":"MDE_optimizers/","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"beginaligned\n    Delta_T(vartheta X_epsilon) = int_R^d left frac1T int_0^T expleft(i u^top X_epsilon(t)right)  dt - int_R^d expleft(i u^top xright) mu(vartheta x)  dx right^2 varphi(u)  du\nendaligned","category":"page"},{"location":"MDE_optimizers/","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"vartheta in Theta subset mathbbR^p is the parameter to be estimated and the data X_epsilon comes in form of a time series from a multiscale process, cf. Multiscale System and Homogenized Limit Pairs.","category":"page"},{"location":"MDE_optimizers/","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"The specific implementation of the MDE depends highly on the chosen limit model, i.e. the homogenized limit process X to which the multiscale process X_epsilon converges weakly as epsilon rightarrow 0. This limit model is characterized by the invariant density mu of the limit process X. Building an estimator on basis of the invariant density leads to parameter identification problems which is why the implementation demands a prior estimation parameter (either diffusion or drift parameter) as input. ","category":"page"},{"location":"MDE_optimizers/","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"Another component of the MDE is the weight function varphi which is, in all considered cases, chosen as a centered Gaussian density with covariance matrix beta^2 I_d beta  0, because this particular choice simplifies the computational cost of the implementation.","category":"page"},{"location":"MDE_optimizers/#Functions","page":"Optimization Task of the MDE","title":"Functions","text":"","category":"section"},{"location":"MDE_optimizers/","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"MDE","category":"page"},{"location":"MDE_optimizers/#MDEforM.MDE","page":"Optimization Task of the MDE","title":"MDEforM.MDE","text":"MDE(data::Vector{<:Real}, limit_model::String, prior_parameter::Real, ϑ_initial::Real; verbose::Bool=false)\n\nReturn MDE value for given data in form of a time series, a defining limit_model, a prior estimation parameter prior_parameter, and an initial point ϑ_initial of the involved optimization procedure.\n\nThe optimization task\n\nbeginaligned\n  argmin_vartheta in Theta Delta_T(X_epsilon vartheta Sigma V)\nendaligned\n\nis implemented and solved with the Julia package Optim.jl. Here, X_ϵ is a one-dimensional time series of length T, obtained from a multiscale SDE, Delta_T is the associated cost functional of the MDE, see Δ, Sigma is the prior_parameter, and V is a potential that is, in the given case, quadratic, i.e. V(x)=x^22.\n\n\n\nArguments\n\ndata::Vector{<:Real}:       one-dimensional time series X_ϵ.\nlimit_model::String:        defining limit model; thus far only supports \"Langevin\" and \"Fast Chaotic Noise\".\nprior_parameter::Real:      prior estimation parameter; limit diffusion parameter in the \"Langevin\" case and limit drift parameter in the \"Fast Chaotic Noise\" case.\nϑ_initial::Real:            initial point of the numerical optimization procedure.\n'verbose::Bool=false':        if verbose = true, then detailed information on the optimization will be printed in real-time.\n\n\n\nExamples\n\njulia> using MDEforM\njulia> limit_drift_parameter = 1.0\njulia> data = Fast_chaotic([1.0, 1.0, 1.0, 1.0], A=-limit_drift_parameter, B=0.0, λ=2/45, ϵ=0.1, T=1000)\njulia> MDE(data, \"Fast Chaotic Noise\", limit_drift_parameter, 10.0)\n\n\n\nSee also Δ_grad_ϑ.\n\n\n\n\n\nMDE(data::Vector{<:Real}, limit_model::String, V::Function, prior_parameter::Real, ϑ_initial::Real; verbose::Bool=false)\n\nReturn MDE value for given data in form of a time series, a defining limit_model, a general potential V, a prior estimation parameter prior_parameter, and an initial point ϑ_initial of the involved optimization procedure.\n\nThe optimization task\n\nbeginaligned\n  argmin_vartheta in Theta Delta_T(X_epsilon vartheta Sigma V)\nendaligned\n\nis implemented and solved with the Julia package Optim.jl. Here, X_ϵ is a one-dimensional time series of length T, obtained from a multiscale SDE, Delta_T is the associated cost functional of the MDE, see Δ, Sigma is the prior_parameter, and V is a general potential.\n\n\n\nArguments\n\ndata::Vector{<:Real}:    one-dimensional time series X_ϵ.\nlimit_model::String:        defining limit model; thus far only supports \"Langevin\" and \"Fast Chaotic Noise\".\nV::Function:                potential V that defines the invariant density of the limit model.\nprior_parameter::Real:   prior estimation parameter; limit diffusion parameter in the \"Langevin\" case and limit drift parameter in the \"Fast Chaotic Noise\" case.\nϑ_initial::Real:         initial point of the numerical optimization procedure.\n'verbose::Bool=false':              if verbose = true, then detailed information on the optimization will be printed in real-time.\n\n\n\nExamples\n\n$ julia --threads 10 --project=. # start julia with 10 threads and activate project\n\njulia> using MDEforM\njulia> limit_drift_parameter = 1.0\njulia> data = Fast_chaotic([1.0, 1.0, 1.0, 1.0], A=limit_drift_parameter, B=1.0, λ=2/45, ϵ=10^(-3/2), T=100)\njulia> V = NLDO()[1]\njulia> MDE(data, \"Fast Chaotic Noise\", V, limit_drift_parameter, 0.8)\n\n\n\nSee also Δ_grad_ϑ, Δ_grad_Σ, μ.\n\n\n\n\n\nMDE(data::Array{<:Real, 2}, limit_diffusion::Array{<:Real, 2}, ϑ_initial::Array{<:Real, 2}; verbose::Bool=false)\n\nReturn MDE value for given data in form of a time series, a prior estimation parameter limit_diffusion, and an initial point ϑ_initial of the involved optimization procedure.\n\nThe optimization task\n\nbeginaligned\n  argmin_vartheta in Theta Delta_T(X_epsilon vartheta Sigma V)\nendaligned\n\nis implemented and solved with the Julia package Optim.jl. Here, X_ϵ is a two-dimensional time series of length T, obtained from a multiscale SDE, Delta_T is the associated cost functional of the MDE, see Δ, Sigma is the prior 2x2 limit diffusion matrix. The initial point ϑ_initial must satisfy certain parameter constraints since the optimization has nonlinear contraints, see manuscript or source code.\n\n\n\nArguments\n\ndata::::Array{<:Real, 2}:             two-dimensional time series X_ϵ.\nlimit_diffusion::Array{<:Real, 2}:    positive definite limit diffusion matrix Sigma in mathbbR^2 times 2.\nϑ_initial::Array{<:Real, 2}:          initial point vartheta_0 in mathbbR^2 times 2 of the numerical optimization procedure.\n'verbose::Bool=false':                if verbose = true, then detailed information on the optimization will be printed in real-time.\n\n\n\nExamples\n\njulia> using MDEforM\njulia> M = [4 2;2 3]\njulia> σ = 1.5               \njulia> p1, p2 = (x -> sin(x), x -> 1/2*sin(x))     \njulia> p1_prime, p2_prime = (x-> cos(x), x -> 1/2*cos(x))\njulia> CorrK = [K(p1, σ) 0 ; 0 K(p2, σ)]\njulia> A = CorrK*M # true parameter; the parameter that ought to be estimated\njulia> Σ = σ*CorrK\njulia> data = Langevin([-5.0, -5.0], [0.0, 0.0], func_config=(p1_prime, p2_prime), M=M, σ=σ, ϵ=0.1, T=1000)[1]\njulia> ϑ_initial = [3.0 0.5*Σ[1]; 0.5*Σ[4] 6.0]\njulia> MDE(data, Σ, ϑ_initial)\n\n\n\nSee also Δ.\n\n\n\n\n\n","category":"function"},{"location":"MDE_optimizers/#Index","page":"Optimization Task of the MDE","title":"Index","text":"","category":"section"},{"location":"MDE_optimizers/","page":"Optimization Task of the MDE","title":"Optimization Task of the MDE","text":"Pages = [\"MDE_optimizers.md\"]","category":"page"},{"location":"MDE_functionals/#Cost-Functionals-for-the-MDE","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"","category":"section"},{"location":"MDE_functionals/","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"In its most general form, the cost functional of the MDE is given by","category":"page"},{"location":"MDE_functionals/","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"beginaligned\n    Delta_T(vartheta X_epsilon) = int_R^d left frac1T int_0^T expleft(i u^top X_epsilon(t)right)  dt - int_R^d expleft(i u^top xright) mu(vartheta x)  dx right^2 varphi(u)  du\nendaligned","category":"page"},{"location":"MDE_functionals/","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"Choosing a centered Gaussian density with covariance matrix beta^2 I_d beta  0, for varphi reduces the above formula to","category":"page"},{"location":"MDE_functionals/","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"beginaligned\n    Delta_T(vartheta X_epsilon) = \n    frac1T^2 int_0^T int_0^T k(X_epsilon(t)-X_epsilon(s))  dt  ds 025cm\n    - frac2T int_0^T (mu(vartheta) ast k)(X_epsilon(t))  dt + int_R^d (mu(vartheta) ast k)(x) mu(vartheta x)  dx\nendaligned","category":"page"},{"location":"MDE_functionals/","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"where k(x) =exp(-beta^2 x_2^22) is the characteristic function of varphi and ast denotes the convolution operator on R^d. Furthermore, if mu(vartheta) is the density of a centered multivariate normal distribution with a positive definite covariance matrix M(vartheta) in R^d times d, then","category":"page"},{"location":"MDE_functionals/","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"beginaligned\n  Delta_T(vartheta X_epsilon) = - frac2T sqrtdet(I_d + beta^2 M(vartheta))  int_0^T expleft( -fracbeta^22 X_epsilon(t)^top left( I_d + beta^2 M(vartheta) right)^-1 X_epsilon(t) right)  dt 025cm\n    + frac1sqrtdet(I_d + 2 beta^2 M(vartheta))\nendaligned","category":"page"},{"location":"MDE_functionals/#Cost-Functionals","page":"Cost Functionals for the MDE","title":"Cost Functionals","text":"","category":"section"},{"location":"MDE_functionals/","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"k\nΔ","category":"page"},{"location":"MDE_functionals/#MDEforM.k","page":"Cost Functionals for the MDE","title":"MDEforM.k","text":"k(x::Real, β::Real)\n\nReturn β and function value of the characteristic function of a centered Gaussian density with standard deviation β at the point x as a tuple.\n\nThis characteristic function is given by\n\nbeginaligned\n  k_beta(x) = expleft( -fracbeta^2 x^22 right) quad x in R\nendaligned\n\nIt is used in the definition of the MDE and is thoroughly outlined in the main manuscript in the numerics section.\n\n\n\nArguments\n\nx::Real:         argument x at which to evaluate the function.\nβ::Real:         positive number beta.\n\n\n\n\n\n","category":"function"},{"location":"MDE_functionals/#MDEforM.Δ","page":"Cost Functionals for the MDE","title":"MDEforM.Δ","text":"Δ(data::Vector{<:Real}, ϑ::Real, Σ::Real, V::Function)\n\nCompute cost functional for given data and parameter values ϑ and Σ.\n\nA properly discretized version of the cost functional, given by\n\nbeginaligned\n  Delta_T(X_epsilon vartheta Sigma V) = - frac2T int_0^T (mu(vartheta Sigma V) ast k_beta)(X_epsilon(t))  dt + int_R (mu(vartheta Sigma V) ast k_beta)(x) mu(vartheta Sigma x)  dx\nendaligned\n\nis implemented and evaluated via multithreading. Here, X_ϵ is a one-dimensional time series of length T, obtained from a multiscale SDE, mu is the invariant density of the homogenized limit SDE, k_beta refers to k, and ast is the convolution operator on R. See the main manuscript for details on this functional. It is the core object of the MDE.\n\nwarning: Warning\nThe computational cost of this function is quite high due to the integration of the convolutions, so if the data is finely discretized, then the running times for a single evalutation are relatively long. Remember that, in this case of a  non-quadratic potential, further simplifications of the above formula are not known thus far.\n\nnote: Note\nWhen comparing the above formula with the formula from the main manuscript, then one notices that the double integral term is missing above.  This is on purpose because the double integral does not depend on any parameters with respect to which we will optimize.\n\n\n\nArguments\n\ndata::Vector{<:Real}:       one-dimensional time series X_ϵ.\nϑ::Real:                    positive drift coefficient vartheta.\nΣ::Real:                    positive diffusion coefficient Sigma.\nV::Function:                defining potential function V for the invariant density.\n\n\n\nExamples\n\n$ julia --threads 10 --project=. # start julia with 10 threads and activate project\n\njulia> Threads.nthreads()\njulia> using MDEforM\njulia> data = Langevin(1.0, 0.0, func_config=NLDO(), α=2.0, σ=1.0, ϵ=0.1, T=100)[1]\njulia> Δ(data, 1, 1, NLDO()[1])\n\n\n\n\n\nΔ(data::Vector{<:Real}, ϑ::Real, Σ::Real)\n\nCompute cost functional for given one-dimensonal data and parameter values ϑ and Σ in the case where the invariant density of the homogenized limit SDE is centered Gaussian.\n\nA properly discretized version of the cost functional, given by\n\nbeginaligned\n  Delta_T(X_epsilon vartheta Sigma V) = -frac2T sqrt1 + beta^2 fracSigmavartheta  int_0^T expleft( -fracbeta^2 X_epsilon(t)^22 (1 + beta^2 fracSigmavartheta) right)  dt + frac1sqrt1 + 2 beta^2 fracSigmavartheta\nendaligned\n\nis implemented. Here, X_ϵ is a one-dimensional time series of length T, obtained from a multiscale SDE, and beta comes from k. The potential is here V(x) = x^22. See the main manuscript for details on this functional. It is the core object of the MDE.\n\nnote: Note\nThe evaluation is, compared to Δ, extremely fast, even for finely discretized data, which signifies the utility of choosing a centered Gaussian weight k in this Gaussian case.\n\n\n\nArguments\n\ndata::Vector{<:Real}:       one-dimensional time series X_ϵ.\nϑ::Real:                    positive drift coefficient vartheta.\nΣ::Real:                    positive diffusion coefficient Sigma.\n\n\n\nExamples\n\njulia> using MDEforM\njulia> data = Langevin(1.0, 0.0, func_config=LDO(), α=2.0, σ=1.0, ϵ=0.1, T=100)[1]\njulia> Δ(data, 1, 1)\n\n\n\n\n\nΔ(data::Array{<:Real, 2}, ϑ::Array{<:Real, 2}, Σ::Array{<:Real, 2})\n\nCompute cost functional for given two-dimensonal data and parameter values ϑ and Σ in the case where the invariant density of the homogenized limit SDE is centered Gaussian.\n\nA properly discretized version of the cost functional, given by\n\nbeginaligned\n  Delta_T(X_epsilon vartheta Sigma) = - frac2T sqrtdet(I_d + beta^2 M(vartheta Sigma))  int_0^T expleft( -fracbeta^22 X_epsilon(t)^top left( I_d + beta^2 M(vartheta Sigma) right)^-1 X_epsilon(t) right)  dt 025cm\n    + frac1sqrtdet(I_d + 2 beta^2 M(vartheta Sigma))\nendaligned\n\nis implemented. Here, X_ϵ is a two-dimensional time series of length T, obtained from a multiscale SDE, M(vartheta Sigma) in R^2 times 2 is a matrix depending on vartheta and Sigma and is given by the covariance matrix of the invariant Gaussian density, and beta comes from k. See the main manuscript for details on this functional and the appearing quantities. It is the core object of the MDE.\n\nnote: Note\nThe evaluation is, compared to Δ, extremely fast, even for finely discretized two-dimensional data, which signifies the utility of choosing a two-dimensional centered Gaussian weight k in this Gaussian case.\n\n\n\nArguments\n\ndata::Array{<:Real, 2}:         two-dimensional time series X_ϵ.\nϑ::Array{<:Real, 2}:            positive definite drift matrix vartheta in mathbbR^2 times 2.\nΣ::Array{<:Real, 2}:            positive definite diffusion matrix Sigma in mathbbR^2 times 2.\n\n\n\nExamples\n\njulia> using MDEforM\njulia> M=[4 2;2 3]\njulia> σ = 5.0  \njulia> data = Langevin([-5.0, -5.0], [0.0, 0.0], func_config=(x-> cos(x), x -> 1/2*cos(x)), M=M, σ=σ, ϵ=0.1, T=100.0)[1]\njulia> CorrK = [K(x-> cos(x), σ) 0 ; 0 K(x -> 1/2*cos(x), σ)]\njulia> ϑ = CorrK*M\njulia> Σ = σ*CorrK\njulia> Δ(data, ϑ, Σ)\n\n\n\n\n\n","category":"function"},{"location":"MDE_functionals/#Gradients-of-Cost-Functionals","page":"Cost Functionals for the MDE","title":"Gradients of Cost Functionals","text":"","category":"section"},{"location":"MDE_functionals/","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"Δ_grad_ϑ\nΔ_grad_Σ","category":"page"},{"location":"MDE_functionals/#MDEforM.Δ_grad_ϑ","page":"Cost Functionals for the MDE","title":"MDEforM.Δ_grad_ϑ","text":"Δ_grad_ϑ(data::Vector{<:Real}, ϑ::Real, Σ::Real, V::Function)\n\nCompute gradient of cost functional Δ with respect to ϑ for given data and parameter values ϑ and Σ and a potential V.\n\nA properly discretized version of the gradient of the cost functional, given by\n\nbeginaligned\n  partial_vartheta Delta_T(X_epsilon vartheta Sigma V) = -frac2T int_0^T (partial_vartheta mu(vartheta Sigma V) ast k_beta)(X_epsilon(t))  dt + 2 int_R (mu(vartheta Sigma V) ast k_beta)(x) partial_vartheta mu(vartheta Sigma x)  dx\nendaligned\n\nis implemented and evaluated via multithreading. Here, X_ϵ is a one-dimensional time series of length T, obtained from a multiscale SDE, mu is the invariant density of the homogenized limit SDE corresponding to μ, k_beta refers to k, and ast is the convolution operator on R.\n\nwarning: Warning\nThe computational cost of this function is quite high due to the integration of the convolutions, so if the data is finely discretized, then the running times for a single evalutation are relatively long. Remember that, in this case of a  non-quadratic potential, further simplifications of the above formula are not known thus far.\n\n\n\nArguments\n\ndata::Vector{<:Real}:       one-dimensional time series X_ϵ.\nϑ::Real:                    drift coefficient vartheta.\nΣ::Real:                    positive diffusion coefficient Sigma.\nV::Function:                defining potential function V for the invariant density.\n\n\n\nExamples\n\n$ julia --threads 10 --project=. # start julia with 10 threads and activate project\n\njulia> Threads.nthreads()\njulia> using MDEforM\njulia> data = Langevin(1.0, 0.0, func_config=NLDO(), α=2.0, σ=1.0, ϵ=0.1, T=100)[1]\njulia> Δ_grad_ϑ(data, 1, 1, NLDO()[1])\n\n\n\nSee also Δ.\n\n\n\n\n\nΔ_grad_ϑ(data::Vector{<:Real}, ϑ::Real, Σ::Real)\n\nCompute gradient of cost functional Δ with respect to ϑ for given one-dimensonal data and parameter values ϑ and Σ.\n\nA properly discretized version of the gradient of the cost functional, given by\n\nbeginaligned\n    partial_vartheta Delta_T(X_epsilon vartheta Sigma V) \n    = fracbeta^2 SigmaT left( 1 + beta^2 fracSigmavartheta right)^52 vartheta^3 int_0^T left left( X_epsilon(t)^2 beta^2 - 1 right)vartheta - beta^2 Sigma right expleft( -fracbeta^2 X_epsilon(t)^22 (1 + beta^2 fracSigmavartheta) right)  dt 025cm\n    + fracbeta^2 Sigmaleft( 1 + 2 beta^2 fracSigmavartheta right)^32 vartheta^2\nendaligned\n\nis implemented. Here, X_ϵ is a one-dimensional time series of length T, obtained from a multiscale SDE, and beta comes from k. The potential is here V(x) = x^22. \n\n\n\nArguments\n\ndata::Vector{Real}:         one-dimensional time series X_ϵ.\nϑ::Real:                    drift coefficient vartheta.\nΣ::Real:                    positive diffusion coefficient Sigma.\n\n\n\nExamples\n\njulia> using MDEforM\njulia> data = Langevin(1.0, 0.0, func_config=LDO(), α=2.0, σ=1.0, ϵ=0.1, T=100)[1]\njulia> Δ_grad_ϑ(data, 1, 1)\n\n\n\nSee also Δ.\n\n\n\n\n\n","category":"function"},{"location":"MDE_functionals/#MDEforM.Δ_grad_Σ","page":"Cost Functionals for the MDE","title":"MDEforM.Δ_grad_Σ","text":"Δ_grad_Σ(data::Vector{<:Real}, ϑ::Real, Σ::Real, V::Function)\n\nCompute gradient of cost functional Δ with respect to Σ for given data and parameter values ϑ and Σ and a potential V.\n\nA properly discretized version of the gradient of the cost functional, given by\n\nbeginaligned\n  partial_Sigma Delta_T(X_epsilon vartheta Sigma V) = -frac2T int_0^T (partial_Sigma mu(vartheta Sigma V) ast k_beta)(X_epsilon(t))  dt + 2 int_R (mu(vartheta Sigma V) ast k_beta)(x) partial_Sigma mu(vartheta Sigma x)  dx\nendaligned\n\nis implemented and evaluated via multithreading. Here, X_ϵ is a one-dimensional time series of length T, obtained from a multiscale SDE, mu is the invariant density of the homogenized limit SDE corresponding to μ, k_beta refers to k, and ast is the convolution operator on R.\n\nwarning: Warning\nThe computational cost of this function is quite high due to the integration of the convolutions, so if the data is finely discretized, then the running times for a single evalutation are relatively long. Remember that, in this case of a  non-quadratic potential, further simplifications of the above formula are not known thus far.\n\n\n\nArguments\n\ndata::Vector{<:Real}:       one-dimensional time series X_ϵ.\nϑ::Real:                    drift coefficient vartheta.\nΣ::Real:                    positive diffusion coefficient Sigma.\nV::Function:                defining potential function V for the invariant density.\n\n\n\nExamples\n\n$ julia --threads 10 --project=. # start julia with 10 threads and activate project\n\njulia> Threads.nthreads()\njulia> using MDEforM\njulia> data = Langevin(1.0, 0.0, func_config=NLDO(), α=2.0, σ=1.0, ϵ=0.1, T=100)[1]\njulia> Δ_grad_Σ(data, 1, 1, NLDO()[1])\n\n\n\nSee also Δ.\n\n\n\n\n\n","category":"function"},{"location":"MDE_functionals/#Index","page":"Cost Functionals for the MDE","title":"Index","text":"","category":"section"},{"location":"MDE_functionals/","page":"Cost Functionals for the MDE","title":"Cost Functionals for the MDE","text":"Pages = [\"MDE_functionals.md\", \"MDE_gradients.md\"]","category":"page"}]
}
